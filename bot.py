# bot.py

import logging
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.error import BadRequest 
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler
from twilio.rest import Client
import os
import threading
from flask import Flask
import re

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Globals
user_sessions = {}  # user_id -> {'sid': str, 'auth': str, 'client': Client, 'number': str}

# States for ConversationHandlers
AWAITING_CREDENTIALS = 0  # For login conversation

# ---- Menu Texts with Emojis (Standard Font) ----
START_COMMAND_TEXT = 'ЁЯПа /start' # Start button text
LOGIN_TEXT = 'ЁЯФС Login'
BUY_TEXT = 'ЁЯЫТ Buy Number' 
SHOW_MESSAGES_TEXT = 'тЬЙя╕П Show Messages'
REMOVE_NUMBER_TEXT = 'ЁЯЧСя╕П Remove Number' 
LOGOUT_TEXT = 'тЖкя╕П Logout'
SUPPORT_TEXT = 'ЁЯТм Support'

# ---- Callback Data Constants ----
PURCHASE_CALLBACK_PREFIX = 'purchase_' 
CONFIRM_REMOVE_YES_CALLBACK = 'confirm_remove_yes'
CONFIRM_REMOVE_NO_CALLBACK = 'confirm_remove_no'
DIRECT_REMOVE_AFTER_SHOW_MSG_CALLBACK = 'direct_remove_this_number'

# Persistent menu - Updated Layout
menu_keyboard = [
    [START_COMMAND_TEXT, LOGIN_TEXT],
    [BUY_TEXT, SHOW_MESSAGES_TEXT], 
    [REMOVE_NUMBER_TEXT, LOGOUT_TEXT],
    [SUPPORT_TEXT]
]
reply_markup = ReplyKeyboardMarkup(menu_keyboard, resize_keyboard=True, one_time_keyboard=False)

# Flask App for Keep-Alive
flask_app = Flask(__name__)

@flask_app.route('/')
def keep_alive_route():
    return 'Bot is alive and kicking!'

def run_flask():
    port = int(os.environ.get('PORT', 8080))
    flask_app.run(host='0.0.0.0', port=port)

# --- Helper function to format codes/OTPs in message body ---
def format_codes_in_message(body: str) -> str:
    if not body: return ""
    patterns = [
        r'\b(G-\d{6})\b', r'\b([A-Z0-9]{7,8})\b', r'\b([A-Z0-9]{6})\b',
        r'\b(\d{7,8})\b', r'\b(\d{6})\b', r'\b(\d{4,5})\b',
    ]
    all_matches = []
    for pattern in patterns:
        for match in re.finditer(pattern, body):
            pre_char = body[match.start()-1:match.start()] if match.start() > 0 else ""
            post_char = body[match.end():match.end()+1] if match.end() < len(body) else ""
            if pre_char != '`' and post_char != '`':
                 all_matches.append({'start': match.start(), 'end': match.end(), 'text': match.group(0)})
    if not all_matches: return body
    all_matches.sort(key=lambda m: (m['start'], -(m['end'] - m['start'])))
    unique_matches = []
    last_processed_end = -1
    for match in all_matches:
        if match['start'] >= last_processed_end:
            unique_matches.append(match)
            last_processed_end = match['end']
    result_parts = []
    current_pos = 0
    for match in unique_matches:
        if match['start'] > current_pos: result_parts.append(body[current_pos:match['start']])
        result_parts.append(f"`{match['text']}`")
        current_pos = match['end']
    if current_pos < len(body): result_parts.append(body[current_pos:])
    return "".join(result_parts)

# --- Helper function to display numbers with inline buy buttons ---
async def display_numbers_with_buy_buttons(message_object, context: ContextTypes.DEFAULT_TYPE, available_numbers, intro_text: str):
    if not available_numbers:
        await message_object.reply_text(f"ЁЯШФ {intro_text} ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржХрзЛржирзЛ ржЙржкрж▓ржнрзНржп ржиржорзНржмрж░ ржирзЗржЗред")
        return
    message_parts = [f"ЁЯУЮ {intro_text} ржЙржкрж▓ржмрзНржз ржиржорзНржмрж░ ржирж┐ржЪрзЗ ржжрзЗржУрзЯрж╛ рж╣рж▓рзЛред ржиржорзНржмрж░ржЯрж┐ ржЪрзЗржкрзЗ ржзрж░рзЗ ржХржкрж┐ ржХрж░рждрзЗ ржкрж╛рж░рзЗржи:\n"]
    keyboard_buttons = []
    for number_obj in available_numbers:
        copyable_number_text = f"`{number_obj.phone_number}`"
        message_parts.append(copyable_number_text)
        button_text = f"ЁЯЫТ ржХрж┐ржирзБржи {number_obj.phone_number}"
        callback_data = f"{PURCHASE_CALLBACK_PREFIX}{number_obj.phone_number}"
        keyboard_buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    if not keyboard_buttons:
         await message_object.reply_text("ЁЯШФ ржиржорзНржмрж░ ржкрж╛ржУрзЯрж╛ ржЧрзЗрж▓рзЗржУ ржмрж╛ржЯржи рждрзИрж░рж┐ ржХрж░рж╛ ржпрж╛рзЯржирж┐ред")
         return
    full_message_text = "\n".join(message_parts)
    inline_reply_markup = InlineKeyboardMarkup(keyboard_buttons)
    await message_object.reply_text(full_message_text, reply_markup=inline_reply_markup, parse_mode='Markdown')

# --- Telegram Bot Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user: logger.warning("Start command/button received with no effective_user."); return
    logger.info(f"User {user.id} ({user.full_name or 'N/A'}) triggered start or start button.")
    await update.message.reply_text(
        f"ЁЯСЛ рж╕рзНржмрж╛ржЧрждржо! '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрж╛ржкрзБржи ржЕржержмрж╛ ржорзЗржирзБ ржерзЗржХрзЗ ржЕржирзНржп ржХрзЛржирзЛ ржЕржкрж╢ржи ржмрзЗржЫрзЗ ржирж┐ржиред",
        reply_markup=reply_markup 
    )

async def login_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if user_id in user_sessions:
        await update.message.reply_text("тЬЕ ржЖржкржирж┐ ржЗрждрж┐ржоржзрзНржпрзЗржЗ рж▓ржЧржЗржи ржХрж░рж╛ ржЖржЫрзЗржиред", reply_markup=reply_markup)
        return ConversationHandler.END
    await update.message.reply_text("ЁЯУЭ ржЖржкржирж╛рж░ Twilio Account SID ржПржмржВ Auth Token ржПржЦрж╛ржирзЗ ржжрж┐ржи, ржПржХржЯрж┐ рж╕рзНржкрзЗрж╕ ржжрж┐рзЯрзЗ ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ (ржпрзЗржоржи: ACxxxxxxxxxxxxxx xxxxxxxxxxxxxx ):")
    return AWAITING_CREDENTIALS

async def receive_credentials(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    user_input = update.message.text.strip()
    main_menu_button_texts = [START_COMMAND_TEXT, LOGIN_TEXT, BUY_TEXT, SHOW_MESSAGES_TEXT, REMOVE_NUMBER_TEXT, LOGOUT_TEXT, SUPPORT_TEXT]  
    if user_input in main_menu_button_texts:  
        await update.message.reply_text(
            f"тЬЛ ржПржЗ рж╕ржорзЯрзЗ ржмрж╛ржЯржи ржирж╛ ржЪрзЗржкрзЗ, ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржкржирж╛рж░ Twilio Account SID ржПржмржВ Auth Token ржЯрж╛ржЗржк ржХрж░рзЗ ржкрж╛ржарж╛ржиред"
            f" ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рждрзЗ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрж╛ржкрзБржиред"
        )
        return ConversationHandler.END  
    try:
        sid, auth = user_input.split(maxsplit=1)
        if not (sid.startswith("AC") and len(sid) == 34):
            await update.message.reply_text(f"тЪая╕П ржЖржкржирж╛рж░ ржжрзЗржУржпрж╝рж╛ SID (`{sid}`) рж╕ржарж┐ржХ ржлрж░ржорзНржпрж╛ржЯрзЗ ржирзЗржЗ ржмрж▓рзЗ ржоржирзЗ рж╣ржЪрзНржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрзЗржкрзЗ рж╕ржарж┐ржХ SID ржУ Auth Token ржжрж┐ржи.", parse_mode='Markdown')
            return ConversationHandler.END
        client = Client(sid, auth)
        client.api.accounts(sid).fetch()  
        user_sessions[user_id] = {'sid': sid, 'auth': auth, 'client': client, 'number': None}
        await update.message.reply_text("ЁЯОЙ рж▓ржЧржЗржи рж╕ржлрж▓ рж╣ржпрж╝рзЗржЫрзЗ!", reply_markup=reply_markup)
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(f"тЪая╕П SID ржПржмржВ Auth Token рж╕ржарж┐ржХржнрж╛ржмрзЗ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ SID, рждрж╛рж░ржкрж░ ржПржХржЯрж┐ рж╕рзНржкрзЗрж╕, рждрж╛рж░ржкрж░ Auth Token ржжрж┐ржиред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рждрзЗ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрж╛ржкрзБржи.")
        return ConversationHandler.END
    except Exception as e:  
        logger.error(f"Login failed for user {user_id} (SID: {sid if 'sid' in locals() else 'N/A'}): {e}")
        await update.message.reply_text(f"тЭМ ржЖржкржирж╛рж░ ржжрзЗржУржпрж╝рж╛ SID ржПржмржВ Auth Token ржжрж┐ржпрж╝рзЗ рж▓ржЧржЗржи ржХрж░рждрзЗ ржмрзНржпрж░рзНрже рж╣ржпрж╝рзЗржЫрзЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЖржмрж╛рж░ '{LOGIN_TEXT}' ржмрж╛ржЯржи ржЪрзЗржкрзЗ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред")
        return ConversationHandler.END

async def logout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user: logger.warning("Logout triggered with no effective_user."); return
    user_id = user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
        logger.info(f"User {user_id} ({user.full_name or 'N/A'}) logged out.")
        await update.message.reply_text("тЬЕ ржЖржкржирж┐ рж╕ржлрж▓ржнрж╛ржмрзЗ рж▓ржЧ ржЖржЙржЯ рж╣ржпрж╝рзЗржЫрзЗржиред")  
        await start(update, context) 
    else:
        await update.message.reply_text("тД╣я╕П ржЖржкржирж┐ рж▓ржЧржЗржи ржЕржмрж╕рзНржерж╛ржпрж╝ ржирзЗржЗред", reply_markup=reply_markup)

async def buy_number_direct_ca_handler(update: Update, context: ContextTypes.DEFAULT_TYPE): # Renamed from buy_random_ca_number_handler for clarity
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    if user_sessions[user_id].get('number'):
        current_number = user_sessions[user_id]['number']
        await update.message.reply_text(f"тД╣я╕П ржЖржкржирж╛рж░ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржПржХржЯрж┐ ржиржорзНржмрж░ (`{current_number}`) ржХрзЗржирж╛ ржЖржЫрзЗред ржирждрзБржи ржиржорзНржмрж░ ржХрж┐ржирждрзЗ ржЖржЧрзЗрж░ржЯрж┐ '{REMOVE_NUMBER_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржорзБржЫрзБржиред", parse_mode='Markdown')
        return
    client = user_sessions[user_id]['client']
    try:
        await update.message.reply_text("ЁЯФО ржХрж╛ржирж╛ржбрж╛ ржерзЗржХрзЗ ржЙржкрж▓ржмрзНржз ржиржорзНржмрж░ ржЦрзЛржБржЬрж╛ рж╣ржЪрзНржЫрзЗ, ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзБржи...") # Changed from "рж░рзНржпрж╛ ржирзНржбржо ржПрж░рж┐рзЯрж╛ ржХрзЛржб"
        available_numbers = client.available_phone_numbers("CA").local.list(limit=10)
        await display_numbers_with_buy_buttons(update.message, context, available_numbers, "ржХрж╛ржирж╛ржбрж╛рзЯ ржЙржкрж▓ржмрзНржз") # Generic intro
    except Exception as e:
        logger.error(f"Failed to fetch CA numbers for user {user_id}: {e}") # Changed log message slightly
        await update.message.reply_text("тЪая╕П ржиржорзНржмрж░ ржЖржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред рж╕ржорзНржнржмржд ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржПржЗ ржЕржЮрзНржЪрж▓рзЗрж░ ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБржорждрж┐ ржирзЗржЗ ржЕржержмрж╛ ржЕржирзНржп ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ред")

async def purchase_number_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user: logger.warning("purchase_number_callback_handler: query or query.from_user not found."); return
    await query.answer()  
    user_id = query.from_user.id
    if user_id not in user_sessions:
        try: await query.edit_message_text(text=f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        except BadRequest: pass  
        return
    if user_sessions[user_id].get('number'):
        current_number = user_sessions[user_id]['number']
        try: await query.edit_message_text(text=f"тД╣я╕П ржЖржкржирж╛рж░ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржПржХржЯрж┐ ржиржорзНржмрж░ (`{current_number}`) ржХрзЗржирж╛ ржЖржЫрзЗред ржирждрзБржи ржиржорзНржмрж░ ржХрж┐ржирждрзЗ ржЖржЧрзЗрж░ржЯрж┐ '{REMOVE_NUMBER_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржорзБржЫрзБржиред", parse_mode='Markdown')
        except BadRequest: pass
        return
    try:
        action, number_to_buy = query.data.split('_', 1)
        if action != PURCHASE_CALLBACK_PREFIX.strip('_') or not number_to_buy.startswith('+'):  
            logger.warning(f"Invalid callback data format for purchase: {query.data} for user {user_id}")
            await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБрж░рзЛржзрзЗ рждрзНрж░рзБржЯрж┐ рж╣ржпрж╝рзЗржЫрзЗред")
            return
    except ValueError: 
        logger.warning(f"Callback data splitting error for purchase: {query.data} for user {user_id}")
        await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ ржХрзЗржирж╛рж░ ржЕржирзБрж░рзЛржз ржмрзБржЭрждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред")
        return
    client = user_sessions[user_id]['client']
    try:
        logger.info(f"User {user_id} attempting to purchase number: {number_to_buy}")
        await query.edit_message_text(text=f"тП│ `{number_to_buy}` ржиржорзНржмрж░ржЯрж┐ ржХрзЗржирж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", parse_mode='Markdown')
        incoming_number = client.incoming_phone_numbers.create(phone_number=number_to_buy)
        user_sessions[user_id]['number'] = incoming_number.phone_number
        success_message = f"ЁЯЫНя╕П ржиржорзНржмрж░ `{incoming_number.phone_number}` рж╕ржлрж▓ржнрж╛ржмрзЗ ржХрзЗржирж╛ рж╣ржпрж╝рзЗржЫрзЗ!"
        await query.edit_message_text(text=success_message, reply_markup=None, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Failed to buy number {number_to_buy} for user {user_id}: {e}")
        error_message = f"тЭМ ржПржЗ ржиржорзНржмрж░ржЯрж┐ (`{number_to_buy}`) ржХрж┐ржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред"
        str_error = str(e).lower()
        if "violates a uniqueness constraint" in str_error or "already provisioned" in str_error: error_message += " ржПржЯрж┐ ржЗрждрж┐ржоржзрзНржпрзЗржЗ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ рж░ржпрж╝рзЗржЫрзЗ ржЕржержмрж╛ ржЕржирзНржп ржХрзЗржЙ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржЫрзЗред"
        elif "not be found" in str_error or "not available" in str_error or "no available numbers" in str_error: error_message += " ржиржорзНржмрж░ржЯрж┐ ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржЖрж░ ржЙржкрж▓ржмрзНржз ржирзЗржЗред"
        elif "permission" in str_error or "authorization" in str_error or "not authorized" in str_error: error_message += " ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржПржЗ ржиржорзНржмрж░ржЯрж┐ ржХрзЗржирж╛рж░ ржЕржирзБржорждрж┐ ржирзЗржЗред"
        elif "balance" in str_error: error_message += " ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржкрж░рзНржпрж╛ржкрзНржд ржмрзНржпрж╛рж▓рзЗржирзНрж╕ ржирзЗржЗред"
        else: error_message += " ржПржЯрж┐ ржЙржкрж▓ржмрзНржз ржирж╛ржУ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗ ржЕржержмрж╛ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржЕржирзНржп ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ рж░рзЯрзЗржЫрзЗред"
        await query.edit_message_text(text=error_message, reply_markup=None, parse_mode='Markdown')

async def show_messages_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:  
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    active_number = user_sessions[user_id].get('number')
    if not active_number:  
        await update.message.reply_text(f"тД╣я╕П ржЖржкржирж╛рж░ ржХрзЛржирзЛ ржХрзЗржирж╛ ржиржорзНржмрж░ ржирзЗржЗред ржкрзНрж░ржержорзЗ '{BUY_TEXT}' ржПрж░ ржорж╛ржзрзНржпржорзЗ ржПржХржЯрж┐ ржиржорзНржмрж░ ржХрж┐ржирзБржиред")
        return
    client = user_sessions[user_id]['client']
    try:
        await update.message.reply_text(f"ЁЯУи `{active_number}` ржиржорзНржмрж░рзЗрж░ ржорзЗрж╕рзЗржЬ ржЦрзЛржБржЬрж╛ рж╣ржЪрзНржЫрзЗ...", parse_mode='Markdown')
        messages = client.messages.list(to=active_number, limit=5)  
        reply_message_text = ""
        if not messages:
            reply_message_text = "ЁЯУк ржЖржкржирж╛рж░ ржПржЗ ржиржорзНржмрж░рзЗ ржХрзЛржирзЛ ржирждрзБржи ржорзЗрж╕рзЗржЬ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ред"
        else:
            response_msg_parts = [f"ЁЯУи ржЖржкржирж╛рж░ ржиржорзНржмрж░ (`{active_number}`) ржП ржЖрж╕рж╛ рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ ржорзЗрж╕рзЗржЬ:\n"]
            for msg_instance in messages:
                formatted_body = format_codes_in_message(msg_instance.body if msg_instance.body else "")
                sender_from = msg_instance.from_ if msg_instance.from_ else "N/A"
                time_sent_utc = msg_instance.date_sent 
                time_sent_str = time_sent_utc.strftime('%Y-%m-%d %H:%M:%S UTC') if time_sent_utc else "N/A"
                msg_detail = (f"\nтЮбя╕П **ржкрзНрж░рзЗрж░ржХ:** `{sender_from}`\nЁЯУЭ **ржмрж╛рж░рзНрждрж╛:** {formatted_body}\nЁЯЧУя╕П **рж╕ржоржпрж╝:** {time_sent_str}\n---")
                response_msg_parts.append(msg_detail)
            reply_message_text = "".join(response_msg_parts)
        await update.message.reply_text(reply_message_text, parse_mode='Markdown')

        button_text_direct_remove = "ржПржЗ ржиржорзНржмрж░ржЯрж╛ рж░рж┐ржорзБржн ржХрж░рзБржи" 
        keyboard = [[InlineKeyboardButton(button_text_direct_remove, callback_data=DIRECT_REMOVE_AFTER_SHOW_MSG_CALLBACK)]]
        inline_reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("ржЖржкржирж┐ ржЪрж╛ржЗрж▓рзЗ ржирж┐ржЪрзЗрж░ ржмрж╛ржЯржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржПржЗ ржиржорзНржмрж░ржЯрж┐ рж╕рж░рж╛рж╕рж░рж┐ рж░рж┐ржорзБржн ржХрж░рждрзЗ ржкрж╛рж░рзЗржи:", reply_markup=inline_reply_markup)

    except Exception as e:
        logger.error(f"Failed to fetch messages for user {user_id} on number {active_number}: {e}")
        await update.message.reply_text("тЪая╕П ржорзЗрж╕рзЗржЬ ржЖржирждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред")

async def direct_remove_after_show_msg_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user: logger.warning("direct_remove_callback: query or query.from_user not found."); return
    await query.answer() 
    user_id = query.from_user.id
    if user_id not in user_sessions or not user_sessions[user_id].get('number'):
        try: await query.edit_message_text(text="ЁЯЪл ржХрзЛржирзЛ рж╕ржХрзНрж░рж┐рзЯ ржиржорзНржмрж░ ржирзЗржЗ ржЕржержмрж╛ рж╕рзЗрж╢ржи рж╢рзЗрж╖ рж╣рзЯрзЗ ржЧрзЗржЫрзЗред ржПржЗ ржЕржкрж╢ржиржЯрж┐ ржЖрж░ ржХрж╛ржЬ ржХрж░ржмрзЗ ржирж╛ред")
        except BadRequest: pass 
        return
    number_to_remove = user_sessions[user_id]['number']
    client = user_sessions[user_id]['client']
    try:
        logger.info(f"User {user_id} initiated direct removal for number: {number_to_remove} from show_messages context.")
        await query.edit_message_text(text=f"тП│ `{number_to_remove}` ржиржорзНржмрж░ржЯрж┐ рж╕рж░рж╛рж╕рж░рж┐ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", parse_mode='Markdown')
        incoming_phone_numbers = client.incoming_phone_numbers.list(phone_number=number_to_remove, limit=1)
        if not incoming_phone_numbers:
            await query.edit_message_text(text=f"тЭУ ржиржорзНржмрж░ `{number_to_remove}` ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ ржмрж╛ ржЖржЧрзЗржЗ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред", parse_mode='Markdown')
            user_sessions[user_id]['number'] = None 
            return
        number_sid_to_delete = incoming_phone_numbers[0].sid
        client.incoming_phone_numbers(number_sid_to_delete).delete()
        user_sessions[user_id]['number'] = None
        await query.edit_message_text(text=f"ЁЯЧСя╕П ржиржорзНржмрж░ `{number_to_remove}` рж╕ржлрж▓ржнрж╛ржмрзЗ рж╕рж░рж╛рж╕рж░рж┐ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ!", parse_mode='Markdown', reply_markup=None) 
    except Exception as e:
        logger.error(f"Failed to directly remove number {number_to_remove} for user {user_id}: {e}")
        await query.edit_message_text(text=f"тЪая╕П ржиржорзНржмрж░ `{number_to_remove}` рж░рж┐ржорзБржн ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗред", parse_mode='Markdown', reply_markup=None)

async def remove_number_handler(update: Update, context: ContextTypes.DEFAULT_TYPE): 
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"ЁЯФТ ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрзНрж░ржержорзЗ '{LOGIN_TEXT}' ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж▓ржЧржЗржи ржХрж░рзБржиред")
        return
    active_number = user_sessions[user_id].get('number')
    if not active_number:
        await update.message.reply_text("тД╣я╕П ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ рж░рж┐ржорзБржн ржХрж░рж╛рж░ ржорждрзЛ ржХрзЛржирзЛ рж╕ржХрзНрж░рж┐ржпрж╝ ржиржорзНржмрж░ ржирзЗржЗред")
        return
    confirmation_message = f"тД╣я╕П ржЖржкржирж╛рж░ ржмрж░рзНрждржорж╛ржирзЗ ржХрзЗржирж╛ ржиржорзНржмрж░ржЯрж┐ рж╣рж▓рзЛ: `{active_number}`ред ржЖржкржирж┐ ржХрж┐ ржПржЗ ржиржорзНржмрж░ржЯрж┐ рж░рж┐ржорзБржн ржХрж░рждрзЗ ржирж┐рж╢рзНржЪрж┐ржд?"
    keyboard = [[ 
        InlineKeyboardButton("тЬЕ рж╣рзНржпрж╛ржБ, ржирж┐рж╢рзНржЪрж┐ржд", callback_data=CONFIRM_REMOVE_YES_CALLBACK), 
        InlineKeyboardButton("тЭМ ржирж╛, ржмрж╛рждрж┐рж▓", callback_data=CONFIRM_REMOVE_NO_CALLBACK)
    ]]
    inline_reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(confirmation_message, reply_markup=inline_reply_markup, parse_mode='Markdown')

async def confirm_remove_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user: logger.warning("confirm_remove_callback_handler: query or query.from_user not found."); return
    await query.answer()
    user_id = query.from_user.id
    action = query.data
    if user_id not in user_sessions or not user_sessions[user_id].get('number'):
        try: await query.edit_message_text(text="ЁЯЪл ржПржЗ ржЕржирзБрж░рзЛржзржЯрж┐ ржЖрж░ ржмрзИржз ржиржпрж╝ ржЕржержмрж╛ ржЖржкржирж╛рж░ рж▓ржЧржЗржи рж╕рзЗрж╢ржи ржмрж╛ рж╕ржХрзНрж░рж┐ржпрж╝ ржиржорзНржмрж░ ржирзЗржЗред")
        except BadRequest: pass
        return
    number_to_remove = user_sessions[user_id]['number']
    if action == CONFIRM_REMOVE_YES_CALLBACK:
        client = user_sessions[user_id]['client']
        try:
            logger.info(f"User {user_id} confirmed removal for number: {number_to_remove}")
            await query.edit_message_text(text=f"тП│ `{number_to_remove}` ржиржорзНржмрж░ржЯрж┐ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...", parse_mode='Markdown')
            incoming_phone_numbers = client.incoming_phone_numbers.list(phone_number=number_to_remove, limit=1)
            if not incoming_phone_numbers:
                await query.edit_message_text(text=f"тЭУ ржиржорзНржмрж░ `{number_to_remove}` ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржХрж╛ржЙржирзНржЯрзЗ ржкрж╛ржУржпрж╝рж╛ ржпрж╛ржпрж╝ржирж┐ ржмрж╛ ржЖржЧрзЗржЗ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред", parse_mode='Markdown')
                user_sessions[user_id]['number'] = None  
                return
            number_sid_to_delete = incoming_phone_numbers[0].sid
            client.incoming_phone_numbers(number_sid_to_delete).delete()
            user_sessions[user_id]['number'] = None
            await query.edit_message_text(text=f"ЁЯЧСя╕П ржиржорзНржмрж░ `{number_to_remove}` рж╕ржлрж▓ржнрж╛ржмрзЗ рж░рж┐ржорзБржн ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ!", parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Failed to remove number {number_to_remove} for user {user_id} after confirmation: {e}")
            await query.edit_message_text(text="тЪая╕П ржиржорзНржмрж░ рж░рж┐ржорзБржн ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред")
    elif action == CONFIRM_REMOVE_NO_CALLBACK:
        await query.edit_message_text(text="ЁЯЪл ржиржорзНржмрж░ рж░рж┐ржорзБржн ржХрж░рж╛рж░ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред")

async def handle_general_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()
    if user_id in user_sessions and text.startswith('+') and len(text) > 7 and text[1:].isdigit() and user_sessions[user_id].get('client'):
        await update.message.reply_text("тД╣я╕П ржиржорзНржмрж░ рж╕рж░рж╛рж╕рж░рж┐ ржЯрж╛ржЗржк ржХрж░рзЗ ржХрзЗржирж╛рж░ рж╕рзБржмрж┐ржзрж╛ржЯрж┐ ржЖржкрж╛рждржд ржирзЗржЗред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржорзЗржирзБ ржерзЗржХрзЗ 'ЁЯЫТ Buy Number' ржмрж╛ржЯржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред", reply_markup=reply_markup)
    else:
        if not text.startswith('/'): # Avoid replying to /start if CommandHandler is also present for text
            is_button_text = False
            all_button_texts = [START_COMMAND_TEXT, LOGIN_TEXT, BUY_TEXT, SHOW_MESSAGES_TEXT, REMOVE_NUMBER_TEXT, LOGOUT_TEXT, SUPPORT_TEXT]
            if text in all_button_texts:
                is_button_text = True
            
            if not is_button_text : # Only send "don't understand" if it's not a menu button click
                 await update.message.reply_text("ЁЯдФ ржЖржкржирж╛рж░ ржЕржирзБрж░рзЛржз ржмрзБржЭрждрзЗ ржкрж╛рж░рж┐ржирж┐ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржорзЗржирзБ ржерзЗржХрзЗ ржПржХржЯрж┐ ржЕржкрж╢ржи ржмрзЗржЫрзЗ ржирж┐ржиред", reply_markup=reply_markup)


async def support_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user: logger.warning("Support command received with no effective_user."); return
    logger.info(f"User {user.id} ({user.full_name or 'N/A'}) clicked Support button.")
    support_username = "MrGhosh75" 
    support_message = "рж╕рж╛ржкрзЛрж░рзНржЯрзЗрж░ ржЬржирзНржп, ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржЕрзНржпрж╛ржбржорж┐ржирзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи:"
    keyboard = [[InlineKeyboardButton(f"ЁЯТм ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи @{support_username}", url=f"https://t.me/{support_username}")]]
    inline_reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.message.reply_text(support_message, reply_markup=inline_reply_markup)
    except Exception as e:
        logger.error(f"Error sending support message to user {user.id}: {e}")

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int: 
    logger.info(f"User {update.effective_user.id} cancelled a conversation using /cancel.")
    await update.message.reply_text('тД╣я╕П ржмрж░рзНрждржорж╛ржи ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ ржмрж╛рждрж┐рж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗред', reply_markup=reply_markup)
    return ConversationHandler.END

if __name__ == '__main__':
    TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if TOKEN is None:
        print("рждрзНрж░рзБржЯрж┐: TELEGRAM_BOT_TOKEN ржирж╛ржоржХ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ рж╕рзЗржЯ ржХрж░рж╛ ржирзЗржЗ!")
        logger.critical("TELEGRAM_BOT_TOKEN environment variable not set!")
        exit()  
    
    app = Application.builder().token(TOKEN).build()

    login_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f'^{LOGIN_TEXT}$'), login_command_handler)],
        states={ AWAITING_CREDENTIALS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_credentials)] },
        fallbacks=[CommandHandler('cancel', cancel_conversation)] 
    )
    
    # The ConversationHandler for "Buy Number (Specific Area Code)" is removed as BUY_TEXT is now direct.
    # If you want to re-add it for a different button, define it here and add the handler.

    app.add_handler(login_conv_handler)
    
    # Handler for the "ЁЯПа /start" button text
    app.add_handler(MessageHandler(filters.Regex(f'^{START_COMMAND_TEXT}$'), start))
    # Also keep CommandHandler for users who type /start
    app.add_handler(CommandHandler("start", start)) 

    # MessageHandlers for other menu buttons
    app.add_handler(MessageHandler(filters.Regex(f'^{LOGOUT_TEXT}$'), logout_handler))
    app.add_handler(MessageHandler(filters.Regex(f'^{BUY_TEXT}$'), buy_number_direct_ca_handler)) # Changed to direct handler
    app.add_handler(MessageHandler(filters.Regex(f'^{REMOVE_NUMBER_TEXT}$'), remove_number_handler))
    app.add_handler(MessageHandler(filters.Regex(f'^{SHOW_MESSAGES_TEXT}$'), show_messages_handler)) 
    app.add_handler(MessageHandler(filters.Regex(f'^{SUPPORT_TEXT}$'), support_handler))
    
    # CallbackQueryHandlers
    app.add_handler(CallbackQueryHandler(purchase_number_callback_handler, pattern=f'^{PURCHASE_CALLBACK_PREFIX}'))
    app.add_handler(CallbackQueryHandler(confirm_remove_callback_handler, pattern=f'^{CONFIRM_REMOVE_YES_CALLBACK}$|^{CONFIRM_REMOVE_NO_CALLBACK}$')) 
    app.add_handler(CallbackQueryHandler(direct_remove_after_show_msg_callback, pattern=f'^{DIRECT_REMOVE_AFTER_SHOW_MSG_CALLBACK}$')) 
    
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_general_text))

    print("Flask keep-alive server ржЪрж╛рж▓рзБ рж╣ржЪрзНржЫрзЗ...")
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True  
    flask_thread.start()

    logger.info("ЁЯдЦ Bot starting to poll... (Flask keep-alive server running on a separate thread)")
    app.run_polling()
