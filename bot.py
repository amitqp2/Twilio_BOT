# bot.py

import logging
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.error import BadRequest
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler, CallbackQueryHandler
from twilio.rest import Client
import os
import threading
from flask import Flask
import re

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Globals
user_sessions = {}  # user_id -> {'sid': str, 'auth': str, 'client': Client, 'number': str}

# State for ConversationHandler
LOGIN_AWAITING_CREDENTIALS = range(1)

# ---- Menu Texts with Emojis (Standard Font) ----
# START_TEXT = 'üè† Start / Home' # ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶¨‡¶æ‡¶ü‡¶® ‡¶∏‡¶∞‡¶ø‡ßü‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá
LOGIN_TEXT = 'üîë Login'
BUY_TEXT = 'üõí Buy Number'
SHOW_MESSAGES_TEXT = '‚úâÔ∏è Show Messages'
REMOVE_NUMBER_TEXT = 'üóëÔ∏è Remove Number'
LOGOUT_TEXT = '‚Ü™Ô∏è Logout'
SUPPORT_TEXT = 'üí¨ Support'

# Persistent menu (‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶¨‡¶æ‡¶ü‡¶® ‡¶∏‡¶∞‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá)
menu_keyboard = [
    [LOGIN_TEXT],
    [BUY_TEXT, SHOW_MESSAGES_TEXT, REMOVE_NUMBER_TEXT],
    [LOGOUT_TEXT],
    [SUPPORT_TEXT]
]
reply_markup = ReplyKeyboardMarkup(menu_keyboard, resize_keyboard=True, one_time_keyboard=False)

# Flask App for Keep-Alive
flask_app = Flask(__name__)

@flask_app.route('/')
def keep_alive_route():
    return 'Bot is alive and kicking!'

def run_flask():
    port = int(os.environ.get('PORT', 8080))
    flask_app.run(host='0.0.0.0', port=port)

# --- Helper function to format codes/OTPs in message body ---
def format_codes_in_message(body: str) -> str:
    if not body:
        return ""
    patterns = [
        r'\b(G-\d{6})\b', r'\b([A-Z0-9]{7,8})\b', r'\b([A-Z0-9]{6})\b',
        r'\b(\d{7,8})\b', r'\b(\d{6})\b', r'\b(\d{4,5})\b',
    ]
    all_matches = []
    for pattern in patterns:
        for match in re.finditer(pattern, body):
            pre_char = body[match.start()-1:match.start()] if match.start() > 0 else ""
            post_char = body[match.end():match.end()+1] if match.end() < len(body) else ""
            if pre_char != '`' and post_char != '`':
                 all_matches.append({'start': match.start(), 'end': match.end(), 'text': match.group(0)})
    if not all_matches: return body
    all_matches.sort(key=lambda m: (m['start'], -(m['end'] - m['start'])))
    unique_matches = []
    last_processed_end = -1
    for match in all_matches:
        if match['start'] >= last_processed_end:
            unique_matches.append(match)
            last_processed_end = match['end']
    result_parts = []
    current_pos = 0
    for match in unique_matches:
        if match['start'] > current_pos: result_parts.append(body[current_pos:match['start']])
        result_parts.append(f"`{match['text']}`")
        current_pos = match['end']
    if current_pos < len(body): result_parts.append(body[current_pos:])
    return "".join(result_parts)

# --- Telegram Bot Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user:
        logger.warning("Start command received with no effective_user.")
        return
    
    logger.info(f"User {user.id} ({user.full_name if user.full_name else 'N/A'}) triggered start.")
    await update.message.reply_text(
        f"üëã ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! '{LOGIN_TEXT}' ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ö‡¶æ‡¶™‡ßÅ‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Æ‡ßá‡¶®‡ßÅ ‡¶•‡ßá‡¶ï‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã ‡¶Ö‡¶™‡¶∂‡¶® ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®‡•§",
        reply_markup=reply_markup
    )

async def login_command_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id in user_sessions:
        await update.message.reply_text("‚úÖ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ü‡¶õ‡ßá‡¶®‡•§", reply_markup=reply_markup)
        return ConversationHandler.END
    await update.message.reply_text("üìù ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Twilio Account SID ‡¶è‡¶¨‡¶Ç Auth Token ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶ø‡¶®, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßç‡¶™‡ßá‡¶∏ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡ßá (‡¶Ø‡ßá‡¶Æ‡¶®: ACxxxxxxxxxxxxxx xxxxxxxxxxxxxx ):")
    return LOGIN_AWAITING_CREDENTIALS

async def receive_credentials(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_input = update.message.text.strip()
    # START_TEXT main_menu_button_texts ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶∞‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá
    main_menu_button_texts = [LOGIN_TEXT, BUY_TEXT, SHOW_MESSAGES_TEXT, REMOVE_NUMBER_TEXT, LOGOUT_TEXT, SUPPORT_TEXT] 
    if user_input in main_menu_button_texts: 
        await update.message.reply_text(
            f"‚úã ‡¶è‡¶á ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá ‡¶¨‡¶æ‡¶ü‡¶® ‡¶®‡¶æ ‡¶ö‡ßá‡¶™‡ßá, ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ Twilio Account SID ‡¶è‡¶¨‡¶Ç Auth Token ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§"
            f" ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶§‡ßá '{LOGIN_TEXT}' ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®‡•§"
        )
        return ConversationHandler.END  
    try:
        sid, auth = user_input.split(maxsplit=1)
        if not (sid.startswith("AC") and len(sid) == 34):
            await update.message.reply_text(f"‚ö†Ô∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ SID ({sid}) ‡¶∏‡¶†‡¶ø‡¶ï ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶®‡ßá‡¶á ‡¶¨‡¶≤‡ßá ‡¶Æ‡¶®‡ßá ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ '{LOGIN_TEXT}' ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ö‡ßá‡¶™‡ßá ‡¶∏‡¶†‡¶ø‡¶ï SID ‡¶ì Auth Token ‡¶¶‡¶ø‡¶®.")
            return ConversationHandler.END
        client = Client(sid, auth)
        client.api.accounts(sid).fetch() 
        user_sessions[user_id] = {'sid': sid, 'auth': auth, 'client': client, 'number': None}
        await update.message.reply_text("üéâ ‡¶≤‡¶ó‡¶á‡¶® ‡¶∏‡¶´‡¶≤ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!", reply_markup=reply_markup)
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(f"‚ö†Ô∏è SID ‡¶è‡¶¨‡¶Ç Auth Token ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá SID, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßç‡¶™‡ßá‡¶∏, ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ Auth Token ‡¶¶‡¶ø‡¶®‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶§‡ßá '{LOGIN_TEXT}' ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ö‡¶æ‡¶™‡ßÅ‡¶®.")
        return ConversationHandler.END
    except Exception as e: 
        logger.error(f"Login failed for user {user_id} (SID: {sid if 'sid' in locals() else 'N/A'}): {e}")
        await update.message.reply_text(f"‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ SID ‡¶è‡¶¨‡¶Ç Auth Token ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ '{LOGIN_TEXT}' ‡¶¨‡¶æ‡¶ü‡¶® ‡¶ö‡ßá‡¶™‡ßá ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return ConversationHandler.END

async def logout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user:
        logger.warning("Logout triggered with no effective_user.")
        # Optionally send a message if update.message exists
        if update.message:
            await update.message.reply_text("‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶∏‡¶®‡¶æ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§")
        return

    user_id = user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
        logger.info(f"User {user_id} ({user.full_name if user.full_name else 'N/A'}) logged out.")
        await update.message.reply_text("‚úÖ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶≤‡¶ó ‡¶Ü‡¶â‡¶ü ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶®‡•§") 
        # ‡¶≤‡¶ó‡¶Ü‡¶â‡¶ü‡ßá‡¶∞ ‡¶™‡¶∞ start ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶ï‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá
        await start(update, context)
    else:
        await update.message.reply_text("‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶ø ‡¶≤‡¶ó‡¶á‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶Ø‡¶º ‡¶®‡ßá‡¶á‡•§", reply_markup=reply_markup)
        # ‡¶Ø‡¶¶‡¶ø ‡¶≤‡¶ó‡¶á‡¶® ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡¶æ ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶§‡ßá‡¶ì ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶Æ‡ßá‡¶®‡ßÅ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡¶®:
        # await start(update, context)


async def buy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"üîí ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá '{LOGIN_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return
    client = user_sessions[user_id]['client']
    try:
        available_numbers = client.available_phone_numbers("CA").local.list(limit=10) 
        if not available_numbers:
            await update.message.reply_text("üòî ‡¶è‡¶á ‡¶Æ‡ßÅ‡¶π‡ßÇ‡¶∞‡ßç‡¶§‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶â‡¶™‡¶≤‡¶≠‡ßç‡¶Ø ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡ßá‡¶á‡•§")
            return
        message_parts = ["üìû ‡¶â‡¶™‡¶≤‡¶¨‡ßç‡¶ß ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡¶ø‡¶ö‡ßá ‡¶¶‡ßá‡¶ì‡¶Ø‡¶º‡¶æ ‡¶π‡¶≤‡ßã‡•§ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø ‡¶ö‡ßá‡¶™‡ßá ‡¶ß‡¶∞‡ßá ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:\n"]
        keyboard_buttons = []
        for number_obj in available_numbers:
            copyable_number_text = f"`{number_obj.phone_number}`"
            message_parts.append(copyable_number_text)
            button_text = f"üõí ‡¶ï‡¶ø‡¶®‡ßÅ‡¶® {number_obj.phone_number}"
            callback_data = f"purchase_{number_obj.phone_number}"
            keyboard_buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        if not keyboard_buttons:
              await update.message.reply_text("üòî ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶ó‡ßá‡¶≤‡ßá‡¶ì ‡¶¨‡¶æ‡¶ü‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§")
              return
        full_message_text = "\n".join(message_parts)
        inline_reply_markup = InlineKeyboardMarkup(keyboard_buttons)
        await update.message.reply_text(full_message_text, reply_markup=inline_reply_markup, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Failed to fetch numbers for user {user_id}: {e}")
        await update.message.reply_text("‚ö†Ô∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶Ü‡¶®‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨‡¶§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶è‡¶á ‡¶Ö‡¶û‡ßç‡¶ö‡¶≤‡ßá‡¶∞ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡ßá‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡•§")

async def purchase_number_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user:
        logger.warning("purchase_number_callback_handler: query or query.from_user not found.")
        if query: await query.answer("‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
        return
    await query.answer() 
    user_id = query.from_user.id
    if user_id not in user_sessions:
        try: await query.edit_message_text(text=f"üîí ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá '{LOGIN_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        except BadRequest: pass 
        return
    if user_sessions[user_id].get('number'):
        current_number = user_sessions[user_id]['number']
        try: await query.edit_message_text(text=f"‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ (`{current_number}`) ‡¶ï‡ßá‡¶®‡¶æ ‡¶Ü‡¶õ‡ßá‡•§ ‡¶®‡¶§‡ßÅ‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡¶ø‡¶®‡¶§‡ßá ‡¶Ü‡¶ó‡ßá‡¶∞‡¶ü‡¶ø '{REMOVE_NUMBER_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßÅ‡¶®‡•§", parse_mode='Markdown')
        except BadRequest: pass
        return
    try:
        action, number_to_buy = query.data.split('_', 1)
        if action != "purchase" or not number_to_buy.startswith('+'): 
            logger.warning(f"Invalid callback data format: {query.data} for user {user_id}")
            await query.edit_message_text(text="‚ö†Ô∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡ßá‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡ßá ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            return
    except ValueError:
        logger.warning(f"Callback data splitting error: {query.data} for user {user_id}")
        await query.edit_message_text(text="‚ö†Ô∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡ßá‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
        return
    client = user_sessions[user_id]['client']
    try:
        logger.info(f"User {user_id} attempting to purchase number: {number_to_buy}")
        incoming_number = client.incoming_phone_numbers.create(phone_number=number_to_buy)
        user_sessions[user_id]['number'] = incoming_number.phone_number
        success_message = f"üõçÔ∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `{incoming_number.phone_number}` ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡ßá‡¶®‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!"
        await query.edit_message_text(text=success_message, reply_markup=None, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Failed to buy number {number_to_buy} for user {user_id}: {e}")
        error_message = f"‚ùå ‡¶è‡¶á ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø (`{number_to_buy}`) ‡¶ï‡¶ø‡¶®‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§"
        if "violates a uniqueness constraint" in str(e).lower() or "already provisioned" in str(e).lower(): error_message += " ‡¶è‡¶ü‡¶ø ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßá‡¶â ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶õ‡ßá‡•§"
        elif "not be found" in str(e).lower() or "not available" in str(e).lower(): error_message += " ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø ‡¶è‡¶á ‡¶Æ‡ßÅ‡¶π‡ßÇ‡¶∞‡ßç‡¶§‡ßá ‡¶Ü‡¶∞ ‡¶â‡¶™‡¶≤‡¶¨‡ßç‡¶ß ‡¶®‡ßá‡¶á‡•§"
        else: error_message += " ‡¶è‡¶ü‡¶ø ‡¶â‡¶™‡¶≤‡¶¨‡ßç‡¶ß ‡¶®‡¶æ‡¶ì ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏/‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø ‡¶®‡ßá‡¶á‡•§"
        await query.edit_message_text(text=error_message, reply_markup=None, parse_mode='Markdown')

async def show_messages_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions: 
        await update.message.reply_text(f"üîí ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá '{LOGIN_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return
    if not user_sessions[user_id].get('number'): 
        await update.message.reply_text(f"‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡ßá‡¶®‡¶æ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡ßá‡¶á‡•§ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá '{BUY_TEXT}' ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡¶ø‡¶®‡ßÅ‡¶®‡•§")
        return
    client = user_sessions[user_id]['client']
    twilio_number_str = user_sessions[user_id]['number'] 
    try:
        messages = client.messages.list(to=twilio_number_str, limit=5) 
        if not messages:
            await update.message.reply_text("üì™ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶è‡¶á ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§")
        else:
            response_msg_parts = [f"üì® ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ (`{twilio_number_str}`) ‡¶è ‡¶Ü‡¶∏‡¶æ ‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú:\n"]
            for msg_instance in messages:
                formatted_body = format_codes_in_message(msg_instance.body if msg_instance.body else "")
                sender_from = msg_instance.from_ if msg_instance.from_ else "N/A"
                time_sent = msg_instance.date_sent.strftime('%Y-%m-%d %H:%M:%S') if msg_instance.date_sent else "N/A"
                msg_detail = (f"\n‚û°Ô∏è **‡¶™‡ßç‡¶∞‡ßá‡¶∞‡¶ï:** `{sender_from}`\nüìù **‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ:** {formatted_body}\nüóìÔ∏è **‡¶∏‡¶Æ‡¶Ø‡¶º:** {time_sent}\n---")
                response_msg_parts.append(msg_detail)
            full_response_msg = "\n".join(response_msg_parts)
            await update.message.reply_text(full_response_msg, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Failed to fetch messages for user {user_id} on number {twilio_number_str}: {e}")
        await update.message.reply_text("‚ö†Ô∏è ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶Ü‡¶®‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")

async def remove_number_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_sessions:
        await update.message.reply_text(f"üîí ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá '{LOGIN_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶≤‡¶ó‡¶á‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§")
        return
    active_number = user_sessions[user_id].get('number')
    if not active_number:
        await update.message.reply_text("‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡ßá‡¶á‡•§")
        return
    confirmation_message = f"‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶ï‡ßá‡¶®‡¶æ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø ‡¶π‡¶≤‡ßã: `{active_number}`‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶á ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶§‡ßá ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§?"
    keyboard = [[ InlineKeyboardButton("‚úÖ ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§", callback_data="confirm_remove_yes"), InlineKeyboardButton("‚ùå ‡¶®‡¶æ, ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤", callback_data="confirm_remove_no")]]
    inline_reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(confirmation_message, reply_markup=inline_reply_markup, parse_mode='Markdown')

async def confirm_remove_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    if not query or not query.from_user:
        logger.warning("confirm_remove_callback_handler: query or query.from_user not found.")
        if query: await query.answer("‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
        return
    await query.answer()
    user_id = query.from_user.id
    action = query.data
    if user_id not in user_sessions or not user_sessions[user_id].get('number'):
        try: await query.edit_message_text(text="üö´ ‡¶è‡¶á ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡¶ü‡¶ø ‡¶Ü‡¶∞ ‡¶¨‡ßà‡¶ß ‡¶®‡¶Ø‡¶º ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶≤‡¶ó‡¶á‡¶® ‡¶∏‡ßá‡¶∂‡¶® ‡¶¨‡¶æ ‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡ßá‡¶á‡•§")
        except BadRequest: pass
        return
    number_to_remove = user_sessions[user_id]['number']
    if action == "confirm_remove_yes":
        client = user_sessions[user_id]['client']
        try:
            logger.info(f"User {user_id} confirmed removal for number: {number_to_remove}")
            incoming_phone_numbers = client.incoming_phone_numbers.list(phone_number=number_to_remove, limit=1)
            if not incoming_phone_numbers:
                await query.edit_message_text(text=f"‚ùì ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `{number_to_remove}` ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø„ÄÇ", parse_mode='Markdown')
                user_sessions[user_id]['number'] = None 
                return
            number_sid_to_delete = incoming_phone_numbers[0].sid
            client.incoming_phone_numbers(number_sid_to_delete).delete()
            user_sessions[user_id]['number'] = None
            await query.edit_message_text(text=f"üóëÔ∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `{number_to_remove}` ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!", parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Failed to remove number {number_to_remove} for user {user_id} after confirmation: {e}")
            await query.edit_message_text(text="‚ö†Ô∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
    elif action == "confirm_remove_no":
        await query.edit_message_text(text="üö´ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")

async def handle_general_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()
    if user_id in user_sessions and text.startswith('+') and len(text) > 7 and text[1:].isdigit() and user_sessions[user_id].get('client'):
        number_to_buy = text
        client = user_sessions[user_id]['client']
        if user_sessions[user_id].get('number'):
            await update.message.reply_text(f"‚ÑπÔ∏è ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ (`{user_sessions[user_id]['number']}`) ‡¶ï‡ßá‡¶®‡¶æ ‡¶Ü‡¶õ‡ßá‡•§ ‡¶®‡¶§‡ßÅ‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡¶ø‡¶®‡¶§‡ßá ‡¶Ü‡¶ó‡ßá‡¶∞‡¶ü‡¶ø '{REMOVE_NUMBER_TEXT}' ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßÅ‡¶®‡•§", parse_mode='Markdown')
            return
        try:
            logger.info(f"User {user_id} attempting to purchase {number_to_buy} via general text.")
            incoming_number = client.incoming_phone_numbers.create(phone_number=number_to_buy)
            user_sessions[user_id]['number'] = incoming_number.phone_number
            await update.message.reply_text(f"üõçÔ∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `{incoming_number.phone_number}` ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡ßá‡¶®‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ (‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶á‡¶®‡¶™‡ßÅ‡¶ü)", reply_markup=reply_markup, parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Failed to buy number {number_to_buy} for user {user_id} via general text: {e}")
            error_message = f"‚ùå ‡¶è‡¶á ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞‡¶ü‡¶ø (`{number_to_buy}`) ‡¶ï‡¶ø‡¶®‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ (‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶á‡¶®‡¶™‡ßÅ‡¶ü)"
            if "violates a uniqueness constraint" in str(e).lower() or "already provisioned" in str(e).lower(): error_message = f"‚ö†Ô∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ `{number_to_buy}` ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶ï‡¶æ‡¶â‡¶®‡ßç‡¶ü‡ßá ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßá‡¶â ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶õ‡ßá‡•§"
            elif "AreaCode is required for an address-based search" in str(e): error_message = "‚ÑπÔ∏è ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶ï‡ßá‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ ‡¶ï‡ßã‡¶°‡¶∏‡¶π ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶¶‡¶ø‡¶® ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶â‡¶™‡¶≤‡¶≠‡ßç‡¶Ø ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡¶æ‡¶õ‡¶æ‡¶á ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
            await update.message.reply_text(error_message, parse_mode='Markdown')
    else:
        await update.message.reply_text("ü§î ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡¶®‡¶ø‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßá‡¶®‡ßÅ ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶™‡¶∂‡¶® ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®‡•§", reply_markup=reply_markup)

async def support_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not user:
        logger.warning("Support command received with no effective_user.")
        return
    logger.info(f"User {user.id} ({user.full_name if user.full_name else 'N/A'}) clicked Support button.")
    support_username = "MrGhosh75"
    support_message = "‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®:"
    keyboard = [[InlineKeyboardButton(f"‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶® @{support_username}", url=f"https://t.me/{support_username}")]]
    inline_reply_markup = InlineKeyboardMarkup(keyboard)
    try:
        await update.message.reply_text(support_message, reply_markup=inline_reply_markup)
    except Exception as e:
        logger.error(f"Error sending support message to user {user.id}: {e}")


if __name__ == '__main__':
    TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if TOKEN is None:
        print("‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø: TELEGRAM_BOT_TOKEN ‡¶®‡¶æ‡¶Æ‡¶ï ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶≠‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶¨‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶®‡ßá‡¶á!")
        logger.critical("TELEGRAM_BOT_TOKEN environment variable not set!")
        exit() 
    
    app = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f'^{LOGIN_TEXT}$'), login_command_handler)],
        states={
            LOGIN_AWAITING_CREDENTIALS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_credentials)]
        },
        fallbacks=[] 
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("start", start))
    # START_TEXT ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø MessageHandler ‡¶∏‡¶∞‡¶ø‡ßü‡ßá ‡¶´‡ßá‡¶≤‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá
    # app.add_handler(MessageHandler(filters.Regex(f'^{START_TEXT}$'), start)) 

    app.add_handler(MessageHandler(filters.Regex(f'^{LOGOUT_TEXT}$'), logout_handler))
    app.add_handler(MessageHandler(filters.Regex(f'^{BUY_TEXT}$'), buy_handler)) 
    app.add_handler(MessageHandler(filters.Regex(f'^{REMOVE_NUMBER_TEXT}$'), remove_number_handler))
    app.add_handler(MessageHandler(filters.Regex(f'^{SHOW_MESSAGES_TEXT}$'), show_messages_handler))
    app.add_handler(MessageHandler(filters.Regex(f'^{SUPPORT_TEXT}$'), support_handler))
    
    app.add_handler(CallbackQueryHandler(purchase_number_callback_handler, pattern='^purchase_'))
    app.add_handler(CallbackQueryHandler(confirm_remove_callback_handler, pattern='^confirm_remove_(yes|no)$'))
    
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_general_text))

    print("Flask keep-alive server ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True 
    flask_thread.start()

    logger.info("ü§ñ Bot starting to poll... (Flask keep-alive server running on a separate thread)")
    app.run_polling()
